#lang honu

require prefix allegro_ racket_allegro_5;

randomReal(low, high){
  random(int((high - low) * 100)) / 100 + low
}

color(r, g, b){
  allegro_map_rgb_f(r, g, b)
}

var pi = 3.141592526

screenWidth(){
  allegro_get_display_width(allegro_get_current_display())
}

screenHeight(){
  allegro_get_display_height(allegro_get_current_display())
}

class Asteroid(x, y, size, angle, speed){
  var life = 1
  draw(){
    allegro_draw_filled_circle(x, y, size, color(1, 0, 0))
  }

  distance(x1, y1, x2, y2){
    sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
  }

  touch(x, y, radius){
    distance(x, y, this.x, this.y) < radius + size
  }

  explode(){
    make(){
        new Asteroid(x + randomReal(-size / 2, size / 2), y + randomReal(-size / 2, size / 2), size / 2 + randomReal(-2, 2), random(360), randomReal(1, 3))
    }

    if size > 15 then {
      var max = random(3) + 2;
      [make(): i <- 0 to max]
    } else {
      []
    }
  }

  hit(){
    life := life - 1
  }

  act(){
    x := x + cos(angle * pi / 180) * speed
    y := y + sin(angle * pi / 180) * speed
    when x < 0 then {
      x := screenWidth()
    }
    when x > screenWidth() then {
      x := 0
    }
    when y < 0 then {
      y := screenHeight()
    }
    when y > screenHeight() then {
      y := 0
    }
  }
}

class Player(x, y, angle, speed, shots){
  var turnSpeed = 3
  var dx = 0
  var dy = 0

  var goLeft = false
  var goRight = false
  var goForward = false
  var goBackward = false
  var doShoot = false

  drawShip(){
    var size = 18
    var x1 = x + cos(angle * pi / 180) * size
    var y1 = y + sin(angle * pi / 180) * size
    var twist = 140
    var x2 = x + cos((angle + twist) * pi / 180) * size
    var y2 = y + sin((angle + twist) * pi / 180) * size
    var x3 = x + cos((angle - twist) * pi / 180) * size
    var y3 = y + sin((angle - twist) * pi / 180) * size
    allegro_draw_filled_triangle(x1, y1, x2, y2, x3, y3, color(0, 1, 0))
  }

  draw(){
    drawShip()
  }

  turnLeft(){
    angle := angle - turnSpeed
  }

  turnRight(){
    angle := angle + turnSpeed
  }

  forward(direction){
    var max = 3
    dx := dx + cos(angle * pi / 180) * speed * direction
    dy := dy + sin(angle * pi / 180) * speed * direction
    when dx > max then {
      dx := max
    }
    when dx < -max then {
      dx := -max
    }
    when dy > max then {
      dy := max
    }
    when dy < -max then {
      dy := -max
    }
  }

  act(world){

    when goLeft then turnLeft()
    when goRight then turnRight()
    when goForward then forward(1)
    when goBackward then forward(-1)
    when doShoot then {
      world->addBullet(x, y, angle, sqrt(dx * dx + dy * dy) + 1)
      doShoot := false
    }

    x := x + dx
    y := y + dy
  }

  handleInput(event){
    match event with
      (allegro_KeyboardEvent type source timestamp display keycode unicode modifiers repeat){

        macro direction(){ what:identifier good:expression bad:expression }{
          syntax(
            if type = 'KeyDown and keycode = good then {
              what := true
            } else if type = 'KeyUp and keycode = good then {
              what := false
            } else if type = 'KeyDown and keycode = bad then {
              what := false
            } else {
            })
        }

        direction goLeft 'Left 'Right
        direction goRight 'Right 'Left
        direction goForward 'Up 'Down
        direction goBackward 'Down 'Up

        when type = 'KeyDown and keycode = 'Space then {
          doShoot := true
        }

        /* Good example of where macros can help. The below code is refactored into
         * the macro above. A function could not be used because the variables being
         * modified are not boxed. 
         */

        /*
        if type = 'KeyDown and keycode = 'Left then {
          goLeft := true
          goRight := false
        } else if type = 'KeyUp and keycode = 'Left then {
          goLeft := false
        } else if type = 'KeyDown and keycode = 'Right then {
          goLeft := false
          goRight := true
        } else if type = 'KeyUp and keycode = 'Right then {
          goRight := false
        } else if type = 'KeyDown and keycode = 'Up then {
          goForward := true
          goBackward := false
        } else if type = 'KeyUp and keycode = 'Up then {
          goForward := false
        } else if type = 'KeyDown and keycode = 'Down then {
          goForward := false
          goBackward := true
        } else if type = 'KeyDown and keycode = 'Up then {
          goBackward := false
        } else {
        }
        */
     }
  }
}

class Bullet(x, y, angle, speed){
  var radius = 4
  var alive = true
  draw(){
    allegro_draw_filled_circle(x, y, radius, color(1, 1, 0))
  }

  hit(){
    alive := false
  }

  getX(){ x }
  getY(){ y }

  act(){
    x := x + cos(angle * pi / 180) * speed
    y := y + sin(angle * pi / 180) * speed
  }
}

class World(player){
  var asteroids = []
  var bullets = []

  makeAsteroid(){
    new Asteroid(randomReal(0, screenWidth()), randomReal(0, screenHeight()), randomReal(10, 50), randomReal(0, 360), randomReal(1, 3))
  }

  constructor(){
    asteroids := [makeAsteroid(): i <- 0 to 5]
  }

  draw(){
    allegro_draw_filled_rectangle(0, 0, screenWidth(), screenHeight(), color(0, 0, 0))
    for asteroid in asteroids do {
      asteroid->draw()
    }
    for bullet in bullets do {
      bullet->draw()
    }
    player->draw()
  }

  addBullet(x, y, angle, speed){
    bullets := new Bullet(x, y, angle, speed) :: bullets
  }

  act(){
    asteroids := [asteroid where asteroid.life > 0: asteroid <- asteroids]
    for asteroid in asteroids do {
      asteroid->act()
    }

    for bullet in bullets do {
      bullet->act()
    }

    var more_asteroids = []
    for bullet in bullets do {
      for asteroid in asteroids do {
        when bullet.alive and asteroid->touch(bullet.x, bullet.y, bullet.radius) then {
          asteroid->hit()
          when asteroid.life = 0 then {
            more_asteroids := append(more_asteroids, asteroid->explode())
          }
          bullet->hit()
        }
      }
    }

    asteroids := append(asteroids, more_asteroids)

    alive?(bullet){
      bullet.alive and
      bullet->getX() > 0 and bullet->getX() < screenWidth() and
      bullet->getY() > 0 and bullet->getY() < screenHeight()
    }

    bullets := [bullet where alive?(bullet): bullet <- bullets]

    player->act(this)
  }
}

run_game(queue){
  var need_redraw = false
  var done = false
  var player = new Player(screenWidth() / 2, screenHeight() / 2, 0, 0.2, 5)
  var world = new World(player)
  world->constructor()

  draw(){
    world->draw()
    allegro_flip_display()
  }

  logic(event){
    match event with
      (allegro_KeyboardEvent type source timestamp display keycode unicode modifiers repeat){
        // printf("Pressed ~a\n", keycode)
        if type = 'KeyChar and keycode = 'Escape then {
          done := true
        } else {
          player->handleInput(event)
        }
      }
      (allegro_TimerEvent type source timestamp count error){
        world->act()
        need_redraw := true
      } else {
      }
  }

  while not done {
    when need_redraw and allegro_is_event_queue_empty(queue) then {
      draw()
      need_redraw := false
    }

    logic(allegro_wait_for_event(queue))
  }
}

main(){
  allegro_install_system()
 
  allegro_init_primitives_addon()
  allegro_install_keyboard()
  allegro_init_image_addon()
  allegro_init_font_addon()
  allegro_init_ttf_addon()

  var FPS = 40
  var width = 800
  var height = 600
  
  var display = allegro_create_display(width, height)
  
  var timer = allegro_create_timer(1.0/FPS)
  var queue = allegro_create_event_queue()
  
  allegro_register_event_source(queue, allegro_get_timer_event_source(timer))
  allegro_register_event_source(queue, allegro_get_keyboard_event_source())
  allegro_register_event_source(queue, allegro_get_display_event_source(display))
  
  allegro_start_timer(timer)

  run_game(queue)
  
  allegro_uninstall_system()
}

main()
